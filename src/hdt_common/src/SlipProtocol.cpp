/*----------------------------------------------------------------------------
 * Name:    SlipProtocol.cpp
 * Purpose: base interface class
 * Note(s):
 *----------------------------------------------------------------------------*/

#include <stdio.h>

#include "SlipProtocol.h"
#include "BaseInterface.h"

/*----------------------------------------------------------------------------
  start
 *----------------------------------------------------------------------------*/
int SlipProtocol::Start(void) {
	// create packet fifo
	PacketFifo = new FifoQ(sizeof(PacketType), PACKET_FIFO_SIZE, FifoQ::DISCARD);
	
	// initialize buffer
	ResetBuffer();

	return 1;
}

/*----------------------------------------------------------------------------
  send packet
  adapted from https://www.ietf.org/rfc/rfc1055.txt
 *----------------------------------------------------------------------------*/
int SlipProtocol::SendPacket(PacketType *packet) {
	char *p = &packet->data[0];
	int len = packet->len;
	
	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	Interface->SendByte(END);

     /* for each byte in the packet, send the appropriate character
      * sequence
      */
	while(len--) {
		switch(*p) {
			/* if it's the same code as an END character, we send a
			 * special two character code so as not to make the
			 * receiver think we sent an END
			 */
			case END:
				Interface->SendByte(ESC);
				Interface->SendByte(ESC_END);
				break;
			/* if it's the same code as an ESC character,
			 * we send a special two character code so as not
			 * to make the receiver think we sent an ESC
			 */
			case ESC:
				Interface->SendByte(ESC);
				Interface->SendByte(ESC_ESC);
				break;


			/* otherwise, we just send the character
			 */
			default:
				Interface->SendByte(*p);
		}
		
		p++;
	}

	/* tell the receiver that we're done sending the packet
	 */
	Interface->SendByte(END);

	return 1;
}

/*----------------------------------------------------------------------------
  get packet-64
 *----------------------------------------------------------------------------*/
int SlipProtocol::GetPacket(PacketType *packet) {
	return PacketFifo->Get(packet);
}

/*----------------------------------------------------------------------------
  process
  adapted from https://www.ietf.org/rfc/rfc1055.txt
 *----------------------------------------------------------------------------*/
void SlipProtocol::ProcessByte(char data) {
	char c = data;
	//printf("%d\n", c);

	// check parse state
	switch(State) {
		/* if it's the same code as an ESC character, wait
		 * and get another character and then figure out
		 * what to store in the packet based on that.
		 */
		case(STATE_ESC):	
			switch(c) {
				/* if "c" is not one of these two, then we
				 * have a protocol violation.  The best bet
				 * seems to be to leave the byte alone and
				 * just stuff it into the packet
				 */
				case ESC_END:
					PutByte(END);
					break;
				case ESC_ESC:
					PutByte(ESC);
					break;
				default:
					PutByte(c);
					printf("protocol violation %d\n", c);
					break;
			}
			
			// change state
			State = STATE_NORMAL;
			break;
		default:
			/* handle bytestuffing if necessary
			 */
			switch(c) {
				case(ESC):
					// change state and wait for next byte
					State = STATE_ESC;
					break;

				/* if it's an END character then we're done with
				 * the packet
				 */
				case END:
					/* a minor optimization: if there is no
					 * data in the packet, ignore it. This is
					 * meant to avoid bothering IP with all
					 * the empty packets generated by the
					 * duplicate END characters which are in
					 * turn sent to try to detect line noise.
					 */
					if(PacketBuffer.len)
						PacketFifo->Put(&PacketBuffer);

					ResetBuffer();
					break;

				/* here we fall into the default handler and let
				 * it store the character for us
				 */
				default:
					PutByte(c);
					break;
			}
			break;
	}
}

/*----------------------------------------------------------------------------
  put byte in packet
 *----------------------------------------------------------------------------*/
int SlipProtocol::PutByte(char data) {
	// make sure there is room in buffer
	if(PacketBuffer.len < MAX_PACKET_SIZE) {
		PacketBuffer.data[PacketBuffer.len++] = data;
		return 1;
	}
	// otherwise reset
	else {
		ResetBuffer();
		printf("packet size error\n");
		return 0;
	}
}
